{
    "contents" : "tocbs <- function(data, cal.date){\n  end.cal.period <- as.Date(cal.date, format=\"%Y-%m-%d\")\n  data['t.x']    <- as.numeric(difftime(strptime(data$end_date, format = \"%Y-%m-%d\"), strptime(data$start_date, format = \"%Y-%m-%d\"), units=\"weeks\"))\n  data['T.cal']  <- as.numeric(difftime(end.cal.period, strptime(data$start_date, format = \"%Y-%m-%d\"), units=\"weeks\"))\n  data['x']      <- data['x'] - 1\n  data           <- data[, c(1,2,3,4,7)]\n  #  cbs            <- as.matrix(data[, c(3,2,7)])\n}\n#data.train <- read.csv('/data/clv_data_train.gz', header=F, col.names=c('id', 't.x', 'x', 'm', 'start_date', 'end_date'), colClasses=c('character', 'numeric', 'numeric', 'numeric', 'character', 'character'))\n#data.train <- tocbs(data.train, '2014-06-30')\ndata.train <- read.csv('/data/clv_train_year.gz', header=F, col.names=c('id', 't.x', 'x', 'm', 'start_date', 'end_date'), colClasses=c('character', 'numeric', 'numeric', 'numeric', 'character', 'character'))\ndata.train <- tocbs(data.train, '2014-12-31')\n#data.train          <- data.train[, c(1,2,3,7)]\n\n#data.test <- read.csv('/data/clv_data_test.gz', header=F, col.names=c('id', 't.x', 'x', 'm', 'start_date', 'end_date'), colClasses=c('character', 'numeric', 'numeric', 'numeric', 'character', 'character'))\n#data.test <- tocbs(data.test, '2014-12-31')\ndata.test <- read.csv('/data/clv_test_qtr.gz', header=F, col.names=c('id', 't.x', 'x', 'm', 'start_date', 'end_date'), colClasses=c('character', 'numeric', 'numeric', 'numeric', 'character', 'character'))\ndata.test <- tocbs(data.test, '2015-03-31')\ncolnames(data.test)[3] <- 'x.star'\n\n# root mean squared error\nrmse <- function(est, act) { return(sqrt(mean((est-act)^2))) }\n\n# mean squared logarithmic error\nmsle <- function(est, act) { return(mean((log1p(est)-log1p(act))^2)) }\n\nPlotConditionalExpectedFrequency <- function(result.data, censor, xticklab = NULL, title = \"Conditional Expectation\") {\n  #result.data <- data.validation\n  #censor <- 10\n  x <- result.data[, 'x']\n  x.star <- result.data[, 'x.star']\n  p <- result.data[, 'p']\n  \n  n.bins <- censor + 1\n  transaction.actual <- rep(0, n.bins)\n  transaction.expected <- rep(0, n.bins)\n  bin.size <- rep(0, n.bins)\n  \n  for (cc in 0:censor) {\n    if (cc != censor) {\n      this.bin <- which(cc == x)\n    } else if (cc == censor) {\n      this.bin <- which(x >= cc)\n    }\n    n.this.bin <- length(this.bin)\n    bin.size[cc + 1] <- n.this.bin\n    \n    transaction.actual[cc + 1] <- sum(x.star[this.bin])/n.this.bin\n    transaction.expected[cc + 1] <- sum(p[this.bin])/n.this.bin\n  }\n  x.labels <- 0:(censor)\n  x.labels[censor + 1] <- paste(censor, \"+\", sep = \"\")\n  ylim <- c(0, ceiling(max(c(transaction.actual, transaction.expected)) * 1.1))\n  xlab <- 'Frequency in training period'\n  ylab <- 'Frequency in validation period'\n  plot(transaction.actual, type = \"l\", xaxt = \"n\", col = 1, ylim=ylim, xlab=xlab, ylab=ylab)\n  axis(1, at = 1:length(transaction.actual), labels = x.labels)\n  lines(transaction.expected, lty = 2, col = 2)\n  legend(\"topleft\", legend = c(\"Actual\", \"Model\"), col = 1:2, lty = 1:2, lwd = 1)\n}\n\nPlotFrequencyInTrain <- function(params, cal.cbs, censor, plotZero = FALSE, \n                                 xlab = \"Training period transactions\", ylab = \"Users\", title = \"Frequency of Repeat Transactions\") {\n  cal.cbs <- na.omit(cal.cbs)\n  tryCatch(x <- cal.cbs[, \"x\"], error = function(e) stop(\"Error in pnbd.PlotFrequencyInCalibration: cal.cbs must have a frequency column labelled \\\"x\\\"\"))\n  tryCatch(T.cal <- cal.cbs[, \"T.cal\"], error = function(e) stop(\"Error in pnbd.PlotFrequencyInCalibration: cal.cbs must have a column for length of time observed labelled \\\"T.cal\\\"\"))\n  \n  dc.check.model.params(c(\"r\", \"alpha\", \"s\", \"beta\"), params, \"pnbd.PlotFrequencyInCalibration\")\n  if (censor > max(x)) \n    stop(\"censor too big (> max freq) in PlotFrequencyInCalibration.\")\n  \n  n.x <- rep(0, max(x) + 1)\n  custs = nrow(cal.cbs)\n  \n  for (ii in unique(x)) {\n    n.x[ii + 1] <- sum(ii == x)\n  }\n  \n  n.x.censor <- sum(n.x[(censor + 1):length(n.x)])\n  n.x.actual <- c(n.x[1:censor], n.x.censor)\n  \n  T.value.counts <- table(T.cal)\n  T.values <- as.numeric(names(T.value.counts))\n  n.T.values <- length(T.values)\n  \n  total.probability <- 0\n  \n  n.x.expected <- rep(0, length(n.x.actual))\n  \n  for (ii in 1:(censor)) {\n    this.x.expected <- 0\n    for (T.idx in 1:n.T.values) {\n      T <- T.values[T.idx]\n      if (T == 0) \n        next\n      n.T <- T.value.counts[T.idx]\n      expected.given.x.and.T <- n.T * pnbd.pmf(params, T, ii - 1)\n      if(!is.nan(expected.given.x.and.T)){\n        this.x.expected <- this.x.expected + expected.given.x.and.T\n        total.probability <- total.probability + expected.given.x.and.T/custs\n      }\n    }\n    n.x.expected[ii] <- this.x.expected\n  }\n  n.x.expected[censor + 1] <- custs * (1 - total.probability)\n  \n  col.names <- paste(rep(\"freq\", length(censor + 1)), (0:censor), sep = \".\")\n  col.names[censor + 1] <- paste(col.names[censor + 1], \"+\", sep = \"\")\n  censored.freq.comparison <- rbind(n.x.actual, n.x.expected)\n  colnames(censored.freq.comparison) <- col.names\n  \n  cfc.plot <- censored.freq.comparison\n  \n  if (plotZero == FALSE) \n    cfc.plot <- cfc.plot[, -1]\n  \n  n.ticks <- ncol(cfc.plot)\n  if (plotZero == TRUE) {\n    x.labels <- 0:(n.ticks - 1)\n    x.labels[n.ticks] <- paste(n.ticks - 1, \"+\", sep = \"\")\n  } else {\n    x.labels <- 1:(n.ticks)\n    x.labels[n.ticks] <- paste(n.ticks, \"+\", sep = \"\")\n  }\n  \n  ylim <- c(0, ceiling(max(cfc.plot) * 1.1))\n  barplot(cfc.plot, names.arg = x.labels, beside = TRUE, ylim = ylim, main = title, \n          xlab = xlab, ylab = ylab, col = 1:2)\n  \n  legend(\"topright\", legend = c(\"Actual\", \"Model\"), col = 1:2, lwd = 2)\n}",
    "created" : 1435881414738.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1344465175",
    "id" : "6E42E0FD",
    "lastKnownWriteTime" : 1435902555,
    "path" : "C:/Users/akulkarni/RWorkspace/rfm/clv_header_new.R",
    "project_path" : "clv_header_new.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "r_source"
}